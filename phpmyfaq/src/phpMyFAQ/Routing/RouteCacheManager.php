<?php

/**
 * Route cache manager
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License,
 * v. 2.0. If a copy of the MPL was not distributed with this file, You can
 * obtain one at https://mozilla.org/MPL/2.0/.
 *
 * @package   phpMyFAQ
 * @author    Thorsten Rinne <thorsten@phpmyfaq.de>
 * @copyright 2026 phpMyFAQ Team
 * @license   https://www.mozilla.org/MPL/2.0/ Mozilla Public License Version 2.0
 * @link      https://www.phpmyfaq.de
 * @since     2026-01-18
 */

declare(strict_types=1);

namespace phpMyFAQ\Routing;

use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;

/**
 * Class RouteCacheManager
 *
 * Manages route caching for improved performance in production.
 * Caches compiled RouteCollection to a PHP file and handles cache invalidation.
 */
class RouteCacheManager
{
    private string $cacheDir;
    private bool $debug;

    public function __construct(string $cacheDir, bool $debug = false)
    {
        $this->cacheDir = rtrim($cacheDir, '/');
        $this->debug = $debug;

        // Create a cache directory if it doesn't exist
        if (!is_dir($this->cacheDir)) {
            mkdir($this->cacheDir, 0755, true);
        }
    }

    /**
     * Get routes, either from cache or by loading them.
     *
     * @param string $context The routing context
     * @param callable $loader Callback that loads the routes
     * @return RouteCollection The route collection
     */
    public function getRoutes(string $context, callable $loader): RouteCollection
    {
        $cacheFile = $this->getCacheFile($context);

        // In debug mode or if the cache doesn't exist, always reload
        if ($this->debug || !file_exists($cacheFile)) {
            $routes = $loader();

            // Only write cache in production mode
            if (!$this->debug) {
                $this->writeCache($cacheFile, $routes);
            }

            return $routes;
        }

        // Load from cache
        return $this->readCache($cacheFile);
    }

    /**
     * Clear all route caches.
     */
    public function clear(): void
    {
        $pattern = $this->cacheDir . '/routes_*.php';
        $cacheFiles = glob($pattern);

        if ($cacheFiles !== false) {
            foreach ($cacheFiles as $file) {
                if (file_exists($file)) {
                    unlink($file);
                }
            }
        }
    }

    /**
     * Clear cache for a specific context.
     *
     * @param string $context The routing context
     */
    public function clearContext(string $context): void
    {
        $cacheFile = $this->getCacheFile($context);

        if (file_exists($cacheFile)) {
            unlink($cacheFile);
        }
    }

    /**
     * Check if a cache exists for a context.
     *
     * @param string $context The routing context
     * @return bool True if a cache exists
     */
    public function hasCache(string $context): bool
    {
        return file_exists($this->getCacheFile($context));
    }

    /**
     * Get the cache file path for a context.
     *
     * @param string $context The routing context
     * @return string The cache file path
     */
    private function getCacheFile(string $context): string
    {
        return $this->cacheDir . '/routes_' . $context . '.php';
    }

    /**
     * Write a route collection to a cache file.
     *
     * @param string $cacheFile The cache file path
     * @param RouteCollection $routes The routes to cache
     */
    private function writeCache(string $cacheFile, RouteCollection $routes): void
    {
        $content = '<?php' . PHP_EOL . PHP_EOL;
        $content .= '// This file is auto-generated by RouteCacheManager' . PHP_EOL;
        $content .= '// Do not edit this file manually' . PHP_EOL . PHP_EOL;
        $content .= 'use Symfony\Component\Routing\Route;' . PHP_EOL;
        $content .= 'use Symfony\Component\Routing\RouteCollection;' . PHP_EOL . PHP_EOL;
        $content .= '$routes = new RouteCollection();' . PHP_EOL . PHP_EOL;

        foreach ($routes as $name => $route) {
            $content .= $this->generateRouteCode($name, $route);
        }

        $content .= PHP_EOL . 'return $routes;' . PHP_EOL;

        file_put_contents($cacheFile, $content);
    }

    /**
     * Generate PHP code for a single route.
     *
     * @param string $name The route name
     * @param Route $route The route
     * @return string The generated PHP code
     */
    private function generateRouteCode(string $name, Route $route): string
    {
        $path = var_export($route->getPath(), true);
        $defaults = var_export($route->getDefaults(), true);
        $requirements = var_export($route->getRequirements(), true);
        $options = var_export($route->getOptions(), true);
        $host = var_export($route->getHost(), true);
        $schemes = var_export($route->getSchemes(), true);
        $methods = var_export($route->getMethods(), true);
        $condition = var_export($route->getCondition(), true);

        $code = '$routes->add(' . var_export($name, true) . ', new Route(' . PHP_EOL;
        $code .= '    path: ' . $path . ',' . PHP_EOL;
        $code .= '    defaults: ' . $defaults . ',' . PHP_EOL;
        $code .= '    requirements: ' . $requirements . ',' . PHP_EOL;
        $code .= '    options: ' . $options . ',' . PHP_EOL;
        $code .= '    host: ' . $host . ',' . PHP_EOL;
        $code .= '    schemes: ' . $schemes . ',' . PHP_EOL;
        $code .= '    methods: ' . $methods . ',' . PHP_EOL;
        $code .= '    condition: ' . $condition . PHP_EOL;
        $code .= '));' . PHP_EOL . PHP_EOL;

        return $code;
    }

    /**
     * Read route collection from a cache file.
     *
     * @param string $cacheFile The cache file path
     * @return RouteCollection The cached routes
     */
    private function readCache(string $cacheFile): RouteCollection
    {
        return include $cacheFile;
    }
}
